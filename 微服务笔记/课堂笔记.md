## 课程规划

9天   8+1   八天的微服务      1天的面试强化

RPC、GRPC、protobuf、consul、go-micro、gin、gorm

## 微服务

划分原则

早期：越小越好，最好是一个功能是一个服务

现在：如果资源占用一样，数据操作一样，最好划分在一个服务中



健壮性

### 单体式架构优缺点

+ 复杂度逐渐变高  
+ 技术债务逐渐上升
+ 高内聚、低耦合

### 微服务特性

+ 单一职责

+ 轻量型
+ 独立性
+ 进程隔离->进程安全

### 微服务和单体式的对比

**单体式和微服务对比**

| 新功能开发 | 需要时间               | 容易开发和实现                                   |
| ---------- | ---------------------- | ------------------------------------------------ |
|            | 传统单体架构           | 分布式微服务化架构                               |
| 部署       | 不经常而且容易部署     | 经常发布，部署复杂                               |
| 隔离性     | 故障影响范围大         | 故障影响范围小                                   |
| 架构设计   | 初期技术选型难度大     | 设计逻辑难度大                                   |
| 系统性能   | 相对时间快，吞吐量小   | 相对时间慢，吞吐量大                             |
| 系统运维   | 运维难度简单           | 运维难度复杂                                     |
| 新人上手   | 学习曲线大（应用逻辑） | 学习曲线大（架构逻辑）                           |
| 技术       | 技术单一而且封闭       | 技术多样而且容易开发                             |
| 测试和差错 | 简单                   | 复杂（每个服务都要进行单独测试，还需要集群测试） |
| 系统扩展性 | 扩展性差               | 扩展性好                                         |
| 系统管理   | 重点在于开发成本       | 重点在于服务治理和调度                           |

### RPC协议

go中要求RPC函数的 格式为：

```go
type HelloWorld struct {}

//要求 函数第一个参数为传入参数,第二个参数为传出参数  引用传递  ,返回值有且只能有一个,而且类型必须是error
func (this*HelloWorld)CallFunc(req int,resp*int)error{
	*resp = req +1
	return nil
}
```

rpc注册服务

```go
//注册服务  本质  在内部维护了一张hash表 ,key值是服务名，value值是服务对象
	rpc.RegisterName("hello",new(HelloWorld))
```

> 第一个参数是服务名称,第二个参数是服务对象

rpc服务端代码

```go
type HelloWorld struct {}

//要求 函数第一个参数为传入参数,第二个参数为传出参数  引用传递  ,返回值有且只能有一个,而且类型必须是error
func (this*HelloWorld)CallFunc(req int,resp*int)error{
	*resp = req + 1
	return nil
}

func main(){
	//注册服务  本质  在内部维护了一张hash表
	rpc.RegisterName("hello",new(HelloWorld))

	//能够监听链接
	listener,err := net.Listen("tcp","localhost:1234")
	if err != nil {
		fmt.Println("设置监听失败",err)
		return
	}
	defer listener.Close()

	fmt.Println("开启监听...")
	//建立链接
	conn,err := listener.Accept()
	if err != nil {
		fmt.Println("建立链接失败",err)
		return
	}
	defer conn.Close()

	//用rpc链接
	rpc.ServeConn(conn)
}
```

> + 定义一个服务，结构体，有成员函数，函数是rpc函数格式
> + 注册服务,rpc.RegisterName("hello",new(HelloWorld))
> + 开启监听，建立连接
> + 把rpc服务绑定到连接上

rpc客户端实现

```go
func main(){
	//链接
	conn,err := rpc.Dial("tcp",":1234")
	if err != nil {
		fmt.Println("建立链接失败",err)
		return
	}
	defer conn.Close()

	//调用远程服务
	req := 10
	var resp int
	err = conn.Call("hello.CallFunc",req,&resp)

	fmt.Println("获取的数据为",resp)
}
```

> + 连接服务，并绑定rpc
> + 调用远程服务   conn.Call("hello.CallFunc",req,&resp)  //第一个参数是  服务名.方法名,第二个参数是传入参数，第三个参数是传出参数，返回值是error

### 跨语言rpc实现

go默认的rpc实现是以gob打包和解包，gob是go特有的，不能实现跨语言，如果实现跨语言，需要是用json或者protobuf。

json版本的rpc服务端:

```go
func main(){
	//注册服务  本质  在内部维护了一张hash表
	rpc.RegisterName("hello",new(HelloWorld))

	//能够监听链接
	listener,err := net.Listen("tcp","localhost:1234")
	if err != nil {
		fmt.Println("设置监听失败",err)
		return
	}
	defer listener.Close()

	fmt.Println("开启监听...")
	//建立链接
	conn,err := listener.Accept()
	if err != nil {
		fmt.Println("建立链接失败",err)
		return
	}
	defer conn.Close()

	//用rpc链接
	rpc.ServeCodec(jsonrpc.NewServerCodec(conn))
}
```

> 在最后绑定的时候，以json编解码绑定

json版本的rpc客户端

```go
func main(){
	//链接
	//conn,err := rpc.Dial("tcp",":1234")
	conn,err := net.Dial("tcp",":1234")
	if err != nil {
		fmt.Println("建立链接失败",err)
		return
	}
	defer conn.Close()
	
	//把链接绑定到rpc上,并且以json做序列化
	rpcConn := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))

	//调用远程服务
	req := 10
	var resp int
	err = rpcConn.Call("hello.CallFunc",req,&resp)

	fmt.Println("获取的数据为",resp)
}
```

> + 不能直接连接并绑定，需要先连接，然后绑定rpc并以json做序列化

json版rpc客户端传递的数据：

```go
{"method":"hello.CallFunc","params":[10],"id":0}
```

> 只包含传入参数，没有传出参数

json版rpc服务端返回的数据为：

```json
{"id":0,"result":11,"error":null}
```

> 只返回，表示,结果,error

